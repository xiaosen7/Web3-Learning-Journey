北京大学肖臻老师《区块链技术与应用》公开课\_原文
好，同学们，昨天我们学习了比特币中用到的密码学基础，也了解了比特币的数据结构。那么今天我们来看一下如何设计出一个加密货币。我们首先不考虑去中心化的问题，假设有一个大家都信任的中心化机构，比如说央行，这个央行有权发行数字货币。我们假设大家都知道央行的公钥，那么央行发行数字货币，大家想想应该怎么发行呢？比如说就像我们发行人民币一样行不行？人民币是怎么发行的？印钞厂印出人民币来，上面有各种各样的防伪标记。你要花钱的时候，我好像还带点人民币。这就是人民币，你要买东西的时候就把人民币给对方就行了。这是央行发行的，有央行设计的各种防伪标志。那这个方法我们用在数字货币上行不行？央行也可以发行数字货币。100 元。Signed by central bank, 这就是 100 块钱。看上去比我那纸质的 100 块钱还要大，我们可以发行个 50 块钱。也是 signed by the central bank.发行的数字货币都有央行的私钥签名，然后央行的公钥我们可以认为是大家都知道的。所以我收到一个数字货币，我可以验证一下是不是真的。那么买东西的时候，比如说我需要给你 100 块钱，我就把这个数字货币发给你。你可以验证一下，确实是央行发行的，这就完成了支付的过程。大家觉得这个方案怎么样？你觉得行不行？感觉没什么问题，好像是挺好的一个方案。如果这个方案没有问题的话，那我们就没必要用区块链了。这里面没有区块链对不对？这里用到的是什么？用到的是密码学中的公私钥体系，非对称加密算法，但是没有用到区块链。这个真的没有问题吗？私钥容易泄露，央行的私钥如果泄露的话会有很大问题，这个一般问题不大。如果央行的私钥都会泄露，我们普通老百姓的私钥更容易泄露，那你这个比特币没法用了。货币的发行量是央行说了算，这样容易导致通货膨胀。你不信任央行，如果他像美国央行那样搞量化宽松，发行很多货币，那么就会影响市场的金融秩序，这个都是很合理的担忧。但其实有一个更大的问题。我说这个方法就这么设计，根本不行。比如说我要买东西，我把 100 块钱给你了，然后你把东西给我了，这个东西我可以再复制一份。这数字货币是什么？就是个文件，对不对？这个文件有央行的签名，所以它文件的内容是不可以伪造的，对不对？如果上面写着央行写的 100 块钱，我没法改成 200 块钱，对吧？但是它是可以复制的，我可以把它复制很多份，给你买东西的时候给你一份，给他买东西给他一份，这样可以无限的复制下去，这个跟人民币就不一样了。这个东西我把它给你了，我就没了，就没法花两次，对不对？上面有各种各样的防伪措施，这个很难复制。这就是数字货币跟我们说的纸质货币的一个区别。这个叫什么？叫做双花攻击。Double spending attack，有人管它叫双花攻击。因为花了两次数字货币所面临的一个主要的挑战就是怎么防范 double spending attack。好，刚才说的方案是不行的，我们改进一下，还是央行发行数字货币。但是每个数字货币上得有一个编号，就像人民币也有编号，对不对？比如这个编号叫做 017，那个 50 块钱可能叫 092 都有个编号。然后央行要维护一个数据库，就是一个大的表。上面记录一下每个编号的数字货币是在谁手里。比如说这个币是央行给我的，017 在肖臻手里。花钱的时候，我把数字货币给你了。你不光是要验证一下这个数字货币有没有央行的签名，而且你还要跟央行核实一下，这个数字货币以前我有没有花出去过，会不会我已经给过他了，我现在又给你了。大家听明白了吗？这个场景，你跟银行核实一下，银行一看这个数字货币确实是在我手里的，所以我用它来支付是合法的，同时央行要改一下。比如说这个数字货币现在不在我手里，在他手里，在我们的助教张正超手里，在张手里。以后如果我想再花一次这个数字货币，我再把它给另外一个人。那个人跟央行一核实就发现不对了。这个数字货币我已经花出去过，现在不在我手里了。这就可以防范我们说的 double spending attack。大家听明白了吗？这个方案有什么问题吗？要钱，要么这条记录特别麻烦，就是太麻烦了。比如说任何两个人之间进行支付都要通过央行，这个方案的正确性是没有问题的，而且实践中也是可以这么用的。但这是一个中心化的方案，数字货币的发行是由央行统一控制，而且每一次交易都需要经过央行确认才能证明其合法性。那么我们能不能搞一个去中心化的方案，把央行这个职能改成由广大的用户来共同承担，这就是比特币这个数字货币系统要解决的一个问题。## 数字货币去中心化方案一个去中心化的货币要解决两个问题，一个是数字货币的发行，谁有权利决定发行数字货币？现在没有央行了，都是大家普通老百姓。那怎么决定货币什么时候该发行，该发行多少？第二个问题，怎么验证交易的有效性，怎么防止刚才说的 double spending attack。第一个问题就谁来发行货币，这个在比特币系统中是由挖矿决定的。我们后面会详细讲。我们先讲第二个问题，怎么防范 double spending attack。其实这个问题解决的方案跟我们刚才讲的这个方案是有点类似的。也是需要维护一个数据结构，来检测这个币以前有没有被花过，被谁花过。只不过这个数据结构不是由央行来维护，而是由所有的用户共同维护。这个数据结构就是区块链。比如说有一个用户 A 他获得了发行货币的权利，我们管它叫铸币权。它发行十个比特币，这个叫 Create coin。给 A 十个比特币，我们把这第一个交易写到区块链里。然后 A 拿到这个钱，把它转给 B 和 C 每个人给五个比特币。这个交易需要有 A 的签名证明是经过 A 同意的。同时这个交易还要说明花掉的这个十个比特币是从哪来的。这个地方是从前面那个来的，前面这个我管它叫铸币交易。能够凭空发行货币，就是铸币交易。指明这个地方的钱是哪来的呢？是这个铸币交易的输出中来的。比特币系统中每个交易都包含了输入和输出两部分。输入部分要说明币的来源，输出部分要给出收款人的公钥的哈希。比如说 A 要转给 B 钱，那么就要说明 B 的公钥的哈希是什么。B 又把钱转给 C 和 D。就转给 C 两个比特币，转给 D 三个比特币，同样是要有签名 signed by B。也要说明币的来源，币是从哪来的呢？从这个交易中来的。这个时候 C 有多少钱？C 有两个比特币，五个比特币，一共有七个比特币。比如 C 决定把七个比特币给 E。签字。这个时候 B 的来源稍微复杂一点，有两个是从这儿来的。还有五个是从这儿来的。这就是我们构成了一个小型的区块链。大家注意，这个地方有两种哈希指针。一种哈希指针就是连接各个区块之间的，把它们串起来构成一个链表。我们昨天说的就属于这种哈希指针在这里。还有第二种哈希指针是指向前面某个交易的，像这个指针是为了说明币的来源从哪来的。为什么要说明币的来源？证明这个钱不是凭空捏造的，是有记录的。这个说的很对，同时也是为了防范 double spending。就比如说现在这个 B 已经把钱转给 C 和 D 了，他又来一趟 B 要转给 F 五个比特币签名。还是有 B 的签名。你单纯说验证签名这个交易看上去好像合法，但是它币是从哪来的呢？他还是得从这儿来，对不对？还是要从这儿来。到这里。别的节点收到这个交易之后，查一下，从这个区块往 B 的来源回溯一下，查一查。查到这个地方发现不对了。你当初指的币的来源，这五个币在这个交易中已经被花出去了，就说明这个交易是不合法的，就不会把它接受到区块链里。这就检测 double spending。到这里有问题吗？我们再仔细看一下这里面的转账交易，就是 A 把钱转给 B 这个交易，这个交易需要什么信息？需要有 A 的签名，同时还需要有 B 的地址。就你把钱转给谁，你得知道他的地址。在比特币系统里，这个收款的地址是通过这个公钥推算出来的。比如说这个 B 的地址就是 B 的公钥取哈希，然后经过一些转换得到的，这个地址相当于银行账号。A 要给 B 转钱，A 需要知道 B 的地址。那 A 怎么才能知道 B 的地址呢？B 的公钥是公开的，他会告诉你，这个说的对。但是他会不会告诉所有的人？没有必要告诉所有人。行，这个我们待会儿再回顾一下。就是我们想象日常生活当中，比如说我需要给你转钱，我得知道你的银行账号才能转的过去，对吧？那我怎么才能知道你银行账号？你要告诉我对不对，就是我为什么要给你转钱。比如说我要买个东西，你接受的支付方式是银行转账。那我就问你，你的银行账号是多少，我才能转给你，对不对？银行本身并没有提供这种查询功能，说指定某一个人他账号是多少，我把他查出来，他不是这样的，都是你要告诉我才行。比特币系统是类似的，就是 A 要给 B 转账，B 的地址是多少。比特币系统内部没有提供一种功能去查询某个指定人他所对应的比特币地址，这个得要其他的渠道来获得。比如说某个电商网站，他接受比特币支付，那么他可以在网站上公开他的地址，或者刚才你说的公开他的公钥，公钥反正不用保密。所以很多比特币地址在网站上就是个二维码，你扫一下就可以知道敌人支付。接下来的问题，A 需要知道 B 的地址，B 需要知道 A 的什么信息吗？好像不需要是吧？是 A 给 B 转账，又不是 B 给 A 转账，B 不需要知道 A 什么信息。B 需要知道 A 到底有没有给他转了多少钱。这实际上是下一步，就等于说我这个交易写到区块链里，然后你怎么证明这个交易是已经写进去了，你想说的是这个问题。咱们先说这个东西，要写到区块链之前，其实还要符合一些条件。A 有没有钱转账？就是 A 要给 B 转账，他得有足够的币的来源，对不对？所以他要指向这个铸币的交易，说我确实有十个比特币我能给你转。还是不够的。A 要给 B 转账，B 不需要知道任何信息。币的来源其实是 A 要证明的，不是 B 要证明的。我说 B 要知道 A 的公钥，你们想想为什么这边是 A。证明是他给的钱证明是他给的一种解释是说我得知道钱是哪来的。我突然收到一笔转账，这钱谁转过来我不知道，对吧？A 的公钥代表了 A 的身份，所以必须要知道 A 的公钥，好知道这钱是从哪来的。其实有一个更重要的原因，我说不光是必须要知道 A 的公钥，所有节点都需要知道 A 的公钥。为什么？为了验证 A 的签名，说这个转账交易要是合法的，得是有 A 的签名。昨天我们说过签名是什么？是私钥签名公钥验证。所以区块链上它每个节点都得独立验证。因为有的节点可能是有恶意的，你不能依靠别人。所以我收到这个交易，我得验证一下是不是合法的，这个钱可能不是转给我的，是你们俩之间转账。我是个旁观者，但是我也得验证对不对？所以大家都需要知道 A 的公钥。那问题就来了，怎么才能知道 A 的公钥？这跟你买东西还不太一样。买东西是有个电商网站，我要去那个网站上买东西，我去访问一下网站内容，它公布出来的一个公钥是什么？这个是跟我没关系，是你们俩之间做交易。大家听明白这个问题了吗？有什么想法吗？A 的公钥是这个交易中自己给出来的，就 A 给 B 转账这个交易在它输入里面，我们说输入要说明币的来源，输入当中还要说明 A 的公钥是什么，这是他自己说的。大家有没有觉得有问题？这里没有安全漏洞，是不是怎么能让他自己说？那如果有一个人冒名顶替，比如说 B 的同伙叫 B1。他伪造一个 A 到 B 的转账交易，他用他自己的公钥在输入中说是 A 的公钥，然后用他自己的私钥签个名。那别的节点收到完之后，用这个假造的公钥去验证这个签名，那肯定是对的，对不对？就以为这个交易是合法的那不麻烦了吗？那你不等于把 A 账上的钱给偷走了。啥意思？就是你那个公钥应该跟你账户是联系起来的。这李真同学说的这个是对的，这个问题是存在的，怎么去避免这个问题呢？我们说每个交易分为输入和输出两部分，对吧？输入部分要说明币的来源，然后刚才我说还要说明这个 A 的公钥。输出部分说明什么？要给出收款人的公钥的哈希，你这个钱要转给谁？你要给出他的公钥的哈希，就类似于它的地址。那么这个交易的币是哪来的呢？是这个地方来的对吧？这个铸币交易后面我们会看到，这叫 coin base transaction。它的输出里面有 A 的公钥的哈希。所以你这个转账交易里说明的这个 A 的公钥要跟这个币的来源里面说明的 A 的公钥的哈希要对得上才行。你要是对不上的话，说明这些币的来源你说的是不对的，这个币当初不是给你的。所以这个例子当中，如果有人冒名顶替，把他自己的公钥说成是 A 的公钥。那么这个假的公钥跟前面这个交易当中输出里指定的 A 的公钥的哈希就对不上了，所以验证是通不过的。大家听明白了吗？只有唯一的这个公钥才可以把这个信息解密，这样就证明这张账单只是你的意思是说整个交易加密了。对，我们说比特币系统不加密，你把它改成加密了，用 A 的私钥加密。对，就是证明是我等等 A 的私钥加密之后，别人没法解密它可以的。公钥不是的，我不是反过来加密，是用接收者的公钥加密，然后你收到之后用私钥解密，不是说用我的私钥加密，然后你用我的公钥解密，不是的。这个要不要再强调一点，我给你发送信息用非对称加密体系，是用你的公钥加密，你公开的公钥加密，你收到之后用自己的私钥解密就行了。你需要给我回复的时候再用我的公钥加密，我收到之后再用我自己的私钥解密。就是他可以在这个交易中冒充是自己的，用自己的公钥冒充是 A 的公钥，但是跟前面这个币的来源对不上。对，是没有用。因为它有前面那个查这个过程，查币的来源的过程，冒充的意思其实应该就是他把币的来源的交易，还有对应的那个输出指向前面连一起。这叫不叫伪造？但是这样伪造以后，你验证通不过。就回答刚才有同学问的问题。我一开始说公钥从哪来的？这个交易中 A 自己宣称的那个同学不是说这有安全漏洞，那如果他宣称的就是假的，不就麻烦了吗？这就是他的防范措施。所以这些哈希指针是很有作用的，指的币的来源的哈希指针。在比特币系统当中，我刚才说的这些验证的过程是通过执行脚本来实现的。就每个输入每个交易的输入是一段脚本。包括我刚才说给出公钥，这个公钥也是在这个输入的脚本里指定的，每个交易的输出也是一段脚本。那么验证是不是合法的，就是要把当前这个交易的输入脚本跟前面那个交易，就是提供币的来源的那个交易的输出脚本拼在一起，然后看看能不能顺利执行。如果能执行的话，才说明是合法的。就这个例子当中是把 A 这个交易的输入脚本。A 有一个输入脚本，下面拼接成前面这个交易的输出脚本。合成一段程序，然后运行一下。如果没有任何错误，那么就是通过我们后面有一节课会专门讲一下比特币中的脚本。这个叫做 bitcoin script。我们这个图当中对比特币系统的一些细节做一些简化。这个图里好像每个区块只有一个交易，实际系统当中每个区块可以包括很多个交易，这些交易就组织成 merkle tree，就我们上节课说的那个 merkle tree。每个交易每个区块分成块头和块身两部分。Block header 和 block body。Block header 里包含的是这个区块的一些宏观的信息，比如说用的是比特币的哪个版本的协议。还有区块链当中，指向前一个区块的指针。还有整颗 merkle tree 的根哈希值。还有两个域是跟挖矿相关的，一个是挖矿的难度目标阈值这个 target，还有就是我们说的那个随机数。大家还记得上节课讲的这个挖矿求解的那个 puzzle 吗？整个块头的哈希要小于等于这个目标阈值。那 block header 里存的就是这个目标阈值的一个编码，就叫 NBS。这个域目标域是一个编码，这里注意一点。就这个哈希前一个区块的哈希只算的是区块的块头。我们画区块链我一般是这么画，对吧？有的书上是把这个指针画在上面的，就这中间的指针，它有的是画在上面的。原因就是只有 block header 才有这种哈希指针串联起。实际上你可以把它看成每个区块，你可以看成是两部分。上面这部分是个 block header。然后下面有一个 block body，block body 里有什么呢？有交易列表。取哈希的时候，是把这个块头的所有部分都取哈希。Block body 是不管的。这个 merkle root hash 就已经能够保证了这个 block body 所包含的 transaction list 是没有办法被篡改的。刚才我们的讨论还有一个简化的假设，就我们讨论中好像是每个节点都需要验证所有的交易。实际当中系统中的节点分为全节点和轻节点，这个我们昨天也提过一下。就是有 full node。Light node。全节点是保存所有的信息的，就是区块链的所有信息，然后验证每一个交易。所以全节点也叫做 fully validating node。轻节点有时候叫 light node，它只保存这个 block header 的信息。一般来说，轻节点没有办法独立验证交易的合法性。比如说这个交易是不是 double spending，轻节点不知道，因为他没有存以前的交易信息，他查不出来。系统中大多数节点其实是轻节点，全节点的数目不是很多。我们这节课主要是针对全节点来讲的。因为轻节点没有参与区块链的构造和维护，他只是利用了区块链的一些信息做一些查询之类的。讲到这里，大家对于区块链中包含的内容应该有一个比较清楚的认识。这些内容是怎么被写到区块链里面去的？每个节点都可以发布交易，对吧？每个账户都可以发布交易。这个交易是广播给所有的节点的，有些交易是合法的，有些交易可能是非法的。那么谁来决定哪些交易应该被写到下一个区块中？按照什么样的顺序写进去呢？如果每个节点自己决定行不行。比如我是一个节点，我收到这个网上各种各样的交易，我判断一下哪些是合法的。然后我把它打包写到下一个区块里，我构造出一个本地的区块链，就每个节点独立决定行不行。你说不行，因为可能重复打包交易。我这里打包一个交易，你那里也打包这个交易，这是好事儿。如果一个交易只在我这里打包，在你那里不打包，那就有问题了。你说我打包完之后，我得告诉其他节点，我这有一个包，然后你那可能你也打包这个交易，然后我。可能有两个区块链有相同的交易。如果你不进行整合的话，就每就是你说的跟我说的还不太一样。我说是每个人本地维护一个区块链，你说是本地维护的区块链的内容又有广播给其他节点。你刚才说不行是什么意思？是因为每个人他本。对，这个是个问题。就这样的话一致性得不到保证对吧？我本地维护一个区块链跟你本地维护一个区块链，它不是一条链，对吧？我们说区块链是什么？是个去中心化的账本。那既然是个账本，这个账本里的内容得有一个统一的说法。否则的话，我记的账跟你记的账不一样，那最后按哪个账本来算呢？对不对？所以这个用我们分布式系统的术语来说，叫做账本的内容要取得分布式的共识。分布式的共识。分布式共识，一个比较简单的例子就是分布式的哈希表。比如系统里有很多台机器，共同维护一个全局的哈希表。这里需要取得共识的内容是什么？需要取得共识的是哈希表中包含了哪些 key value pair，对吧？比如说有的人在我这台机器上插入一个 key value pair。像这个 key 对应的是 12345。别人在另一台机器上去读的时候，也要能把这个读出来，这叫一个全局的哈希表。关于这个分布式共识，有很多的理论研究，学术界研究了很多年。我本人的背景是搞分布式系统的，在这方面有很多的论文，而且有很多的不可能结论。这个叫做。Impossibility result.其中最著名的一个就是 FLP impossibility result。这三个字母是三个作者的姓的开头字母，都是分布式系统的专家，他们的结论是什么？在一个异步的系统里叫做。Asynchronous system. 网络传输时延没有上限，这叫异步系统。即使只有一个成员是有问题的，叫做 faulty。那么也不可能取得共识。这个结论是听上去很悲观的。如果这系统的网络传输是异步的，网络时延没有上限，哪怕系统中有一个成员是 faulty，你也没法达成共识。还有一个结论，比较著名的。叫做 cap theorem。这 cap 这三个字母是指分布式系统的三个性质，三个我们想要的性质，C 是 consistency。A 是 availability。P 是 partition tolerance。这个 cap theorem 是说任何一个分布式系统，比如说我们这个分布式哈希表，这三个性质当中最多只能满足两个，不可能三个性质都满足。就比如说如果你想要的是一致性和 availability，你就得不到 partition tolerance。如果你想有 availability 和 partition tolerance，这个系统永远是 available 别人可以用的，就要牺牲 consistency，就不能保证系统状态一定是一致的这就是 cap theorem。分布式共识的一个比较著名的协议。是 paxos。这个协议能够保证一致性。如果这个协议达成了共识，这个共识一定是一致的。不会说一个成员认为的共识跟另外一个成员认为的共识不一样，这个不会的，一定是 consistent。但是某些情况下，paxos 这个协议有可能一直没有办法达成共识。这种可能性在实际系统当中是比较小的，但是客观存在的。我们这门课因为时间关系就不再讲这些分布式理论的内容。这些内容如果要详细讲的话，要讲大概半个学期的课。这些理论跟比特币的实际应用关系是不大的。下面我们看一下比特币中的共识协议。比特币中共识要解决的一个问题是，有些节点可能是有恶意的。我们假设系统中大多数节点是好的，有恶意的毕竟是小部分。那么这种情况下怎么去设计一个共识协议呢？一种想法是，既然系统中大多数节点是好的，那么直接投票行不行？比如说某一个节点它提出一个候选区块，他根据这个收到的交易信息选一下哪些交易是合法的。然后把这些交易按照某个顺序打包到一个区块里，然后他这个候选区块发布给所有的节点。然后每个节点收到这个区块之后，检查一下这里面的交易是不是都是合法的。如果都是合法的话，他就投赞成票。如果有一个交易是非法的，就投反对票。最后算一下得票，如果是超过半数都是赞成的，这个区块就正式接受了。写到区块链里，这是一个投票的方法，行不行呢？就是你担心的是 denial of service，它就这里就这个方案本身是一个粗略的描述，有一些技术细节要落实。比如说我们说某一个节点提出这么一个候选区块，哪个节点提出候选区块？你刚才说的问题就是说如果这个节点本身是有恶意的，他不断的提出一些非法的候选区块，它每个区块里面都有一些非法交易，结果大家就不停的投票，然后时间都浪费在投票上了，这个区块链就没法往下发展了，是这个意思吧？就是如果万一有一半的人就。你说是另外一个问题，就是你没有办法强迫每个节点都投票。有些节点就犯懒，我就不投票，谁的区块我都不投，那这区块链就陷入一个瘫痪状态，叫行政不作为，还有没有问题？还有一个效率上的问题，对吧？因为你说要投票，网络延迟你事先也不是很清楚对吧？你每轮投票等多久，它也有一个效率问题。还有没有别的问题？就这些属于更细节一些的问题，都是实际存在的问题。但他这有一个更大的问题。任何基于投票的方案，首先要确定谁有投票权，对不对？要有个 membership 的问题。如果这个区块链它的 membership 是有严格定义的。比如说你这个不是谁都可以加入的，像我们有的叫联盟链。就 hyperledger。只有某些符合条件的大公司才能加入。大家听说过不？Hyperledger fabric, 对吧？那就是一个联盟链的协议。这种情况下基于投票的方案是可行的。因为我们假设大多数成员是好的，那么我们投下票就是可以的。比特币系统不是这样的，我们昨天刚刚讲完，比特币系统中创建一个账户是很容易的。你就在本地产生一个公钥私钥，对，就是一个账户，不需要任何人批准。其实别人都不知道你产生一个账户，你想你本地产生一个公钥对之后，别人怎么知道呢？你转账的时候别人会知道，就是你光产生一个公钥对你什么事都不干，别人是不知道的。只有你跟外部发生一些交易的时候，别人才知道有这个账户的存在。那这样好啊，你不是要投票吗？有恶意的节点就搞一台超级计算机，别的事都不干，不停的产生各种各样的账户。然后它产生的账户超过总数的一半，他就有控制权了，他就可以操纵投票结果。这种叫什么？叫女巫攻击。Sybil attack.那怎么办呢？投票不行，或者说简单的直接投票是不行的。比特币系统当中用了一个很巧妙的机制来解决这个问题，也是投票，但不是按照账户的数目投票，而是用计算力来投票。每个节点都可以在本地组装出一个候选区块，把它认为合法的交易放到这个区块里。就开始尝试各种 nonce 值。大家还记得我们以前讲的那个 computational puzzle 是什么意思吗？这个 block 的里面有一个域是个随机数。那。组装好区块之后，就开始试各种各样的随机数，这是个四个 bit 的。看哪一个能够满足这个不等式的要求，求出来哈希落在指定范围之内。如果某个节点找到了符合要求的 nonce，我们就说他获得了记账权。所谓的记账权就是往比特币这个去中心化的账本里写入下一个区块的权利。只有找到这个 nonce 获得记账权的节点，才有权利发布下一个区块。其他节点收到这个区块之后，要验证一下这个区块的合法性。比如先验证一下这个 block header 的内容填的对不对，像 block header 有一个域。NBS 域它实际上是这个目标阈值的一个编码。检查一下这个 NBS 域设置的是不是符合比特币协议中规定的难度要求。然后查一下这个 nonce，选出的 nonce，是不是整个 block header 的哈希是小于等于这个目标阈值的。就换句话说，你发布一个区块，你是不是真的有权利发布区块，你是不是真的获得了记账权。就把 block header 中的那几项都查一遍，假设都符合要求，然后看一下 block body 里面的交易列表，验证一下每个交易都是合法的。第一要有合法的签名，第二以前没有被花过。那么如果有任何一个不符合要求，那么这个区块是不能够被接收的，要被放弃掉。假设有一个区块经过检查都是符合要求的那是不是就可以接受它？有没有可能说一个区块我们查过了，block header 符合要求，所有的交易列表也符合要求，但是我们可能仍然不愿意去接受它，有这种可能吗？我们画一个区块链。谁能想象有什么可能？你得稍微大点声。有恶意的节点，然后干嘛呢？就这个情况会出现拒绝。你说这个就是虽然我发布的是个合法的区块，但是这个恶意的节点他就不接收这个合法区块。对，这是有可能的。假设这个节点是个诚实的。诚实的节点。如果所有的交易都是合法的，就应该接受。假设有一个获得记账权的节点。我们画的长一点。发布一个合法的区块是在这个位置。这个区块里所有的交易都是合法的。Block header 也符合要求，我们应不应该接受的？那他是合法的，合法的不就是合法的区块怎么定义？这个可能有一些概念上的混淆，就是我们这里刚才说的合法的，只是说它的区块的内容没有包含非法的交易，每个交易都是有合法的。签名用的币以前都没有被花过，所以每个交易都是合法的。Block header 的每个域设置都是合法的，但是它是插在中间一个位置，他不在后面，他插在中间。我再多问一句，你收到一个区块之后，你怎么知道它差在哪里？这个同学说的对，我们前面讲的有什么 hash of previous block。应该是 previous block header。因为只有 block header 才取哈希，所以根据前一个区块的指针就知道它是插在这个位置。插在这个位置有什么问题吗？比如说这个区块里有一个交易，A 把钱转给 B。下面这个区块里有一个交易，A 又把钱转给他自己了。这个交易本身也是合法的，有同学觉得这可能是非法的对吧？你把钱转给另外一个人，你怎么能又把这个钱再转给自己，这不变成了 double spending。我们判断一个交易是不是 double spending，是看这个区块所在的这个分支，在这个分支上他这个币有没有被花过两次。这个分支是这样的一个分支。比如说这个 A 转给 B 这个交易，它币的来源是这个区块 C 转给 A 一笔钱。所以验证是不是 double spending 的时候，怎么验证从当前这个区块到币的来源之间，中间这些区块有没有把这个币已经花过。那么这个中间的区块是没有花过，所以这个交易是合法的，就验证这个分叉上的这个交易是不是合法。不会查到上面这个分叉，但这个感觉上是不应该接受的，它实际上是在干嘛？他实际上等于把上面这个转账交易给回滚了。本来你是把钱给别人的写到区块链里面了。然后你后面再拿一个区块，把这个钱都转给自己。就虽然这个是交易，这个区块中交易的内容是合法的，但是它不在最长合法链上。我们写在哪儿呢？写这个。不在最长合法链。上面这一个链才是最长合法链，下面这等于是它的一个分支。我们讲的这个例子说明比特币协议中规定接受的区块应该是在扩展最长合法链，所以应该是接在后面才是合法的区块。这个例子其实是一个分叉攻击的例子，这个叫做。Forking attack。通过往区块链中间位置插入一个区块，来回滚某个已经发生了的交易。那么区块链在正常情况下也可能出现分叉，大家能想一下是什么情况吗？同时。对，就是这个场景。如果有两个节点同时获得记账权，我们说他们是怎么获得记账权的呢？每个节点在本地自己组装一个他认为合适的区块，去尝试各种各样的 nonce。如果两个节点在差不多同一个时间找到了符合要求的 nonce，那么都可以把区块发布出去。这时候会出现什么情况？会出现两个等长的分叉。如果你要按照最长合法链这个原则的话，这两个都是最长合法链，都是合法的，那该接受哪一个呢？比特币协议当中，缺省情况下，每个节点是接受它最早收到的那一个。所以不同节点根据在网络中的位置不同，有些节点可能先听到这个区块会接受它，也有些节点可能先听到另一个区块会接受那个区块。那么什么叫做接收一个区块？前面有同学说，恶意的节点可能故意不接受一个合法的区块，那么怎么区分他是接受还是不接受？比特币协议中用的是一种隐式确认机制。就是如果它沿着你这个区块往下继续扩展，就算是认可了你这个发布的区块。比如说他收到这个区块之后，往下又扩展一个新的区块。就表明他是认可了你这个区块，他如果不扩展你这个区块就是没有认可你这个区块。所以如果系统中两个矿工，两个节点差不多同时发布区块的情况，那么这种等长的临时性的分叉会维持一段时间，直到其中有某一个分叉最后胜出。就这个例子当中，一开始就没有这个区块的时候，这两个都是等长的最长合法链。假设上面这个分叉抢先一步，先找到了下一个区块，那这个就变成了最长合法链。下面这个就叫做孤块。就被丢弃掉。大家有问题吗？假设有一大批节点认为另外一个区块是合法的，所以其实就看哪一个区块增长得比较快，最后哪个区块被认可。假如一个分叉被抛弃，那些节点的奖励怎么办？你已经抢先一步了。实际上就是我们要问的，为什么大家要竞争我们说的这个记账权？消耗很多的计算资源去争夺这个记账权，还挺费电的。有什么好处？首先获得记账权的节点本身有一定的权力，他可以决定哪些交易被写到下一个区块里。但是我们设计这个协议的时候，不应该让这个成为争夺记账权的主要动力。如果这个成为主要动力就有点问题了。因为我们是希望什么？凡是合法的交易都应该能够被写入到区块链里。那怎么办呢？在比特币中设计了一个很巧妙的机制来解决这个问题。这个叫做出块奖励。比特币协议中规定，获得记账权的那个节点在发布的区块里可以有一个特殊的交易，就是我们前面说过的铸币交易 coinbase transaction。在这个交易里可以发布一定数量的比特币。我们在这节课开始的时候说过一个去中心化的数字货币要解决两个问题。第一个问题是谁有权发行货币？第二个问题是怎么验证交易的合法性。我们这节课到现在为止都是在讲第二个问题，怎么验证交易的合法性。现在我们回过头来讲第一个问题，谁来决定发行货币这个 coinbase transaction。是比特币系统当中发行新的比特币的唯一方法。其他所有的交易都只不过是把已有的比特币从一个账户转移到另一个账户。包括我们有的时候用法币去购买比特币。像国外有的交易所，你可以开个账户，然后用美元购买比特币。那个也没有产生新的比特币。只不过是说你把美元给了对方，然后对方把他的比特币从他的账户上转到你的账户上，仍然没有产生新的币。这个是唯一一个产生新币的途径。就这个交易不用指明币的来源，因为这个币是凭空造出来的，那能造多少币呢？一开始的时候，比特币刚上线的时候，每一个发布的区块可以产生 50 个比特币，这个 BTC 就是比特币的符号。不同的加密货币都有自己的符号，就像每个股票在上市的时候，股票交易所上它也有一定的符号，这个 BTC 就是比特币的符号，这个出块奖励是 50 个比特币。但是协议中规定 21 万个区块以后，这个区块奖励就要减半，就变成 25 个比特币。一开始的 21 万个区块，每个区块发布的时候可以发行 50 个比特币。之后每个区块里就只能发行 25 个比特币。再过 21 万个区块又要减半，就变成了 12.5 个比特币。这个就是现在的情况，现在每个区块里只能产生 12.5 个比特币。看上去好像减少得很快是吧？现在这个出块奖励只有当初的 1/4 了，而且现在的竞争比以前激烈了很多。一开始比特币系统里没有多少人去竞争这个事情。我们说比特币的传奇创始人叫中本聪。现在大家谁也不知道这是个什么样的人，长啥样，男的还是女的，他名字像是男的，都没有见过这个人。他一开始创立比特币的时候，那时候没有什么节点去争夺这个记账权，就这 50 个比特币很容易就可以得到。但现在的竞争更激烈了，大家要耗费很多的计算资源，使用先进的设备，结果只能得到 12.5 个比特币，但是大家不要忘了，当初的时候，那 50 个比特币是不值钱的，那个时候没有什么人看好比特币。大家听说过一个故事吗？就是比特币第一次跟实体世界发生交互的时候，是有人用 2 万个比特币买了一个比萨饼。大家是不是很怀念以前的那个好时代，一个比萨饼能够换 2 万个比特币。就好像我们怀念北京的房价，一平米 1000 块钱的时候。后来这个减半之后，数量是少了，但是那个时候比特币已经比较值钱了。现在这个 12.5 的时候就是非常值钱了。现在这个比特币的价钱大概是 6000 美元左右，这相当于 8 万美元。所以你发布一个区块可以得到 8 万美元的奖励，这是很大的一笔钱。这就是为什么有很多节点争破了头去抢这个记账权。回到刚才那同学的问题，你实际上想问的是说，出现了分叉，那么有一个分叉胜出了，剩下那个分叉的这个区块，我们管它叫孤块，那么这个区块里这个 coinbase 所得到的这个区块奖励是不是就没有用了？是这个问题吧？基本上是的。如果上面有一个很长的区块链变成了主链最长合法链，你下面有一个分叉里，那个分叉里记得你有多少比特币。但是我们验证交易的时候，是验证你这个区块所在的那个分叉是否正确。那么比特币协议中要求是接受最长合法链。所以如果你这个交易是接在一个很短的分叉后面的，那么这个分叉上面你得到的比特币其实是没有作用的，因为大多数诚实的节点是不会接受的。大家搞清楚比特币这个共识机制了吗？那么我来问个问题，这个共识机制要取得的共识具体是什么？我们前面举的一个例子，就刚才说过这个分布式哈希表。我们讲有一个系统，有很多台服务器共同维护一个分布式哈希表。那个例子当中要取得的共识是什么？是这个哈希表中的内容是吧？包含哪些 key value pair，那个是要取得的共识。那比特币系统中你要取得的共识是什么？就是这个去中心化账本里的内容是大家取得共识的。那么谁能决定这个账本里的内容呢？只有获得记账权的节点才能够往里面写东西。那怎么获得记账权呢？就是解这个 puzzle。所以为什么我们说比特币的共识机制是靠算力来投票？因为我们上一节课讲的这个性质，puzzle friendly, 大家还记得吗？这个性质保证了求解这个步骤的过程没有捷径，只能一个一个 nonce 去试。所以如果某一个节点它的算力是另一个节点的十倍，那么他获得记账权的概率也是那个节点的十倍。就靠算力来投票，这就是比特币中投票的特殊性。它不是一人一票，也不是一台计算机一票，而是看你每秒钟能够尝试多少个 nonce 的数目。这个我们有时候管它叫 hash rate。写在哪呢？写这。这个决定了投票的权重。你这个节点的 hash rate 越高，那么你获得记账权，得到这个出块奖励的概率也是越大的。那我再问一个问题，这个方法怎么能够防范我们前面说的那个问题，那个女巫攻击的问题。Sybil attack.我们讲直接投票的话不行，会有 Sybil attack，怎么避免这个呢？因为你投票是靠算力投的，你创建多少个账户其实是没有影响的。你可以在你的服务器上创建一个账户，创建 100 个账户，创建 1 万个账户，并不会使你的 hash rate 增加，并不会使你每秒钟能够尝试的 nonce 数目增加。所以你投票的权重并没有改变。大家想想有什么问题。大家听说过一种说法吗？就管比特币这个争夺记账权的过程叫做挖矿。Mining. 这个实际上是一种比较形象的说法，就一个比喻，因为比特币有人把它叫做数字黄金。所以求解这个 computational puzzle，去寻找这个 nonce 的过程，就相当于当初的淘金。你找到了合法的 nonce 获得记账权，就能够得到比特币，相当于挖到金矿。所以争夺记账权的节点被称为矿工。如果他获得了记账权，我们有时候就说他挖到矿或者说是挖到区块了。这区块链中的每个区块你可以都理解成这么挖出来的，这么挖矿给挖出来的。比特币系统中的这个挖矿的过程跟以前历史上那些淘金热当中的挖矿的过程有很多类似之处，都很不容易，都很辛苦。都是在一个很大的搜索空间中去寻找，找到的概率很小，但是一旦找到了就能赚一大笔钱，这就是我们加密货币世界里的挖矿。好，到这里为止，我们就把这个比特币系统里的共识机制基本上讲完了。这节课的内容是比较多的，大家回去之后好好消化吸收一下。下节课我们会讲一下比特币系统的具体实现，同时对挖矿的过程做一些数学上的分析。