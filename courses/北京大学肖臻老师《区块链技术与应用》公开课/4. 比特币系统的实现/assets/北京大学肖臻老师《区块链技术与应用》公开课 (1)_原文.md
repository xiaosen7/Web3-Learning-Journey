北京大学肖臻老师《区块链技术与应用》公开课 (1)_原文
2024年10月25日 14:11
00:08
好，上节课我们讲了比特币协议的共识机制，这节课我们讲一下比特币系统的具体实现。我们说区块链是一个去中心化的账本，比特币采用的是基于交易的这种账本模式。

00:44
Transaction based neger每个区块里记录的是交易信息，有转账交易，有铸币交易。但是系统当中并没有哪个地方显示的记录每个账户上有多少钱。比如说你想知道A这个账户上有多少钱，这个需要通过交易记录来推算。区块链中一共有多少往A这个地址上转账的交易，转入了多少个币，这些币当中有哪些已经被花掉了，有哪些还没有。所以这样你就可以推算出A这个账户上当前的余额是多少。比特币系统的全节点要维护一个叫做UTXO的数据结构。

02:03
还没有被花出去的交易的输出。就区块链上有很多交易，有些交易的输出可能已经被花掉了，有些还没有被花掉。所有那些还没有被花掉的交易的输出组成的集合就是这个UTXO。注意，一个交易可能有多个输出，比如说A的一个转账交易。可能是给B转了五个比特币。

02:47
给C转了三个比特币。B拿到这五个比特币之后，把它花掉了，所以这个输出就不在UTXO里面了。C收到这三个比特币还没花出去，所以这个输出是在UTSO里面的，就同一个交易可能有的输出在里面，有的输出不在。这个UTXO集合当中的每个元素，要给出产生这个输出的交易的哈希值，以及它在这个交易里是第几个输出。就这两个信息就可以定位到这一个UTSO中的输出。要这个UTXO集合干嘛用呢？为什么要维护这样一个数据结构？

03:59
对，为了检测double spending，就是新发布的一个交易是不是合法。我们要查一下这个UTSO你想花掉的币只有在这个集合里面才是合法的。如果不在这个集合里面，说明你要花掉这个币，要么是不存在的，要么是以前已经被花过了。所以全节点要在内存中维护UTSO这样一个数据结构，以便快速检测double 3顶。

04:44
每个交易会消耗掉一些输出，同时也会产生新的输出。比如我们这个例子当中，A把五个比特币转给B之后，我们说B把它花出去了。把这五个比特币给D了。

05:10
这个时候这个输出就不在UTSO里面了。但是它要产生一个新的输出，这个输出又要保存在UTSO里面。所以随着交易的发布，每个交易要消耗一些UTSO中的输出，但是又会产生一些新的输出。

05:32
如果某个人收到比特币的转账交易之后，这个钱始终都不花，那么这个信息就要永久的保存在UTSO里面。可能是这个人不像话。比如说我们传说当中的比特币的发明人中本聪，他就是不花的。还有一些人可能是想花没法花，因为他把密钥给丢了。这些东西就属于要永久的保存在UTSO里。我们后面课上会看一些区块链上的实际统计数据，这个UTSO的集合也是逐渐增大，但是到目前为止，装在一个普通的服务器的内存里还是完全没有问题的。

06:25
每个交易可以有多个输入，也可以有多个输出。所有输入的金额加起来要等于所有输出的金额，这个叫做。就这样吧。

06:58
我们这个例子当中是给出了两个输出的例子。输入也可以是有多个的，而且这多个输入不一定是来自于同一个地址。这也是为什么一个交易可能需要有多个签名，每个输入地址都要提供对应的签名。大家看有问题吗？

07:30
我马上就要讲这个东西。

08:00
有些交易，他可能total inputs略微大于total output。比如说total input可能是。一个比特币total of的可能是0.99个比特币。这个里面的差额，这0.0一个比特币就作为交易费给获得记账权发布区块的那个节点。我们上节课说过，为什么节点要消耗计算资源来竞争这个记账权？为了获得区块奖励，你发布一个区块可以有一个特殊的coin base transaction，获得一定数量的比特币作为报酬，所谓的block reward。但是光有这个出块奖励可能是不够的。发布区块的那个节点，为什么要把你的交易打包在区块里？这样做对他有什么好处呢？

09:24
大家觉得有什么好处吗？比如某个比较自私的节点，它可能发布区块的时候只包含他自己的那些交易，别的交易都不管。因为把别的交易打包进去对他来说没什么好处，而且还有一定的代价。因为你要验证这个交易的合法性，而且你区块里如果是装的交易多了的话，它占用的带宽也比较多，在网络上传播的速度也会慢。所以如果只是有出块奖励这个机制的话，就可能会出现有些情况。就是这个节点如果比较自私的话，他就不管别人的交易，他只打包他自己的交易。所以比特币系统设计了第二个激励机制，就是这个交易费，这个叫。

10:30
Traduction 3。

10:37
这个可以理解成是一种小费。你把我的交易打包在这个区块里，我给你一点小费。目前这个比特币系统当中，交易费的金额都很小。像我们这个例子当中，0.0一个比特币就算是比较大的交易费了。有很多交易费只有0.00几个比特币，也有一些简单的交易是没有交易费的。

11:13
目前来说，矿工去挖矿，去争夺这个记账权，主要的目的还是为了得到出块奖励。因为有12.5个比特币，但是我们上节课也讲过，这个出块奖励是要逐渐减小的，每隔21万个区块要减半。21万个区块大概是多长时间呢？

11:57
21万个区块。比特币系统设计的平均出块时间是十分钟，就整个系统平均每隔十分钟会产生一个新的区块。

12:19
1个小时是60分钟。

12:30
一天有24个小时。

12:38
一年有365天。

12:46
说你这么算一下的话，这个差不多是四年的时间。

12:55
就21万个区块，平均下来大概是四年的时间。每隔四年这个出块奖励会减半。那么很多年以后，这个出块奖励可能变得就很小了，到那个时候可能这个交易费就变成主要的。大家有问题吗？

13:37
除了比特币这种transaction tion base的niger之外，与之对应的还有另一种模式是基于账户的模式。

14:03
像我们后面要讲的以太坊用的就是这种模式。在这种模式当中，系统是要显示的记录每个账户上有多少个币。这个跟我们平时的日常体验就比较接近了。就像你要知道你银行账户的余额，你去登录银行网站就可以查得到。

14:30
比特币这种基于交易的模式的隐私保护性比较好一点。但是也有一些代价。比如我们上节课反复强调的比特币当中的转账交易要说明币的来源。为什么要说冥币的来源？

14:58
比如说你要转给别人十个比特币，那谁知道你有没有这十个比特币。他没有这个账户的概念，没有地方记录你一共有多少个比特币。所以每个交易都必须得说清楚，你这个币是从哪儿来的，是从其之前的哪一个交易的哪个输出中来的。就是他没有这种账户的概念，他要付出这个代价。以太坊系统当中就不存在这个问题，我们后面会讲到，就不需要显示的说明B的来源。下面我们看一些区块链上的具体例子。我们看一下比特币系统中的一些具体的区块的信息。

15:54
我们来看一些区块的例子，这个是从blockchain点info这个网站上截的图。这个区块里包含了686个交易。总的输出是这么多个比特币。这是总的交易费，这是把区块里686个交易的交易费加在一起，一共是这么多。最下面一行是出块奖励，我们可以比较一下，这两者差了有100倍，就出块奖励还是大头。跟交易费相比，出块奖励是交易费的差不多100倍。

16:45
这是矿工挖矿的主要动力，还是为了得到这个block reward。这个hit就是区块的序号。Tim stem是这个区块的时间戳，这个是上个月月底产生的。Difficult是挖矿的难度，每隔2016个区块要调整这个难度，保持出块时间在十分钟左右。Nance就是挖矿时尝试的这个随机数，这里的nance值是最后找到的符合难度要求的。

17:38
右边显示的是三个哈希值。第一个是这个区块的块头的哈希值。这是前一个区块的块头的哈希值。注意计算哈希值的时候都是只算block header，不包含block body中具体的交易列表。大家看看这两个哈希值有什么共同的特点。

18:13
前面都有一长串的零，对不对？这个区块的哈希值和上一个区块的哈希值开头都是有一长串的零，这个不是偶然的。我们上节课说过，所谓的挖矿就是不断的调整这个随机数length，使得整个blog header的哈希值小于等于给定的目标阈值。这个目标阈值表示成16进制，就是前面有一长串的零。所以凡是符合难度要求的区块，它的块头的哈希值算出来都是要有一长串的零。这个moko root就是这个区块中包含的那些交易构成的mico trade跟哈希值。

19:09
这是block header的数据结构，这里面的几个域我们上节课已经解释过了，大家注意nance这个语。它的类型是32位的无符号整数。我们说挖矿的时候要调整这个nance，但是这个nance最多只有二的32次方个可能的取值。按照比特币现在的挖矿难度，就算把这二的32次方个可能的取值都遍历一遍，很可能仍然是找不到符合难度要求的。大家听明白了吗？因为最近几年比特币的价格涨得太猛了，挖矿的人太多了，竞争非常激烈，挖矿难度已经被调的非常高了。单纯靠调整block header y这个nance的雨比较大的概率是找不到符合要求的，搜索空间不够大。

20:18
那怎么办呢？这个header的数据结构里还有哪些域是可以调整的吗？这是block header里各个域的描述。

20:34
第一个这个version是当前使用的比特币协议的版本号，这个是没法改的。第二个域是前一个区块的块头的哈希值，这个也没法改。第三个域是moco tree的根哈希值，这个能改吗？

21:00
第四个域是这个区块产生的时间，这个其实是有一定的调整的余地的。比特币系统并不要求非常精确的时间，可以对这里的时间在一定范围内进行调整，只要别太离谱就行。这个域也只有四个字节。

21:24
第五个域是挖矿时候用的目标阈值，这里是这个目标阈值的一个编码后的版本。因为它只有四个字节，是一个编码后的版本。这个只能按照协议中的要求定期进行调整，不能随便改。最后这个域就是我们调整的这个nance。

21:46
既然光改难死不够，那还能改什么呢？这里面还有哪个域可以改吗？改这个跟哈希值。有同学可能觉得奇怪，这个根哈希值怎么能随便改呢？我们前面讲过，每个发布的区块里有一个特殊的铸币交易，coin base transaction, 这是比特币系统中产生新的比特币的唯一方式。这个交易没有输入，因为B是凭空造出来的。还有一个coin base语可以写入任何的内容，你在这个域里写什么内容是没有人管的。

22:38
我们前面讲过的digital commitment，可以把commit的哈希值写在这里。大家还记得吗？我们第一节课的时候讲过，我们当时举的是一个预测股票市场的例子。提前公布预测结果会影响股市。事先可以公布一个预测结果的哈希值，这个哈希值就可以写在考恩贝斯这个域里。因为这个域写什么内容，反正是没有人去检查的。你也可以写点别的东西，比如人生的感想，挖矿不容易，好不容易挖到了，且挖且珍惜。

23:21
那么这个玉对我们有什么用呢？如果我们改变这个域的内容，会对块头里的根哈希值有什么影响吗？这是一个小型区块链的示意图，上面一排是几个block header组成的链表。我们把最后一个block header里的根哈希值对应的moco tree画出来了。左下角这个交易是coin base transaction，我们改的这个coin base域之后。这个交易的哈希值就发生了变化，这个变化会沿着moco tree的结构往上传递。

24:21
最后导致block header里的根哈希值发生变化。所以我们可以把这个域当做extra，as块头里四个字节的nas不够用，这里还有很多字节可以用，比如把coin base这个域的前八个字节当做extra ice来用，这样搜索空间一下子就增大了，到了二的96次方。所以真正挖矿的时候是有两层循环，外层循环调整这个coin base域的extra nth，算出block header里的根哈希值之后，内层循环再调整header里的nas。

25:14
我们再看一个普通的转账交易的例子，这个交易有两个输入和两个输出。这两个写的是output，其实对这个交易来说是输入。这里写的output意思是说他们花掉的是之前那个交易的output。这两个输出都还没有被划掉，都是安斯坦会保存在UTXO里面。输入的总金额是这么多。这是输出的总金额，这两者之间的差值就是这个交易的transaction费。这里可以看到输入和输出都是用脚本的形式来指定的。

26:12
比特币系统中验证交易的合法性，就是把input script和output script配对后执行来完成的。注意，不是把这两个script配对，这两个脚本是同一个交易中的脚本，不是把同一个交易里的输入脚本和输出脚本配对。而是把这个交易里的输入脚本跟前面那个提供B的来源的那个交易里的输出脚本配对。如果输入脚本和输出脚本拼接在一起，能够顺利执行，不出现错误，那么这个交易就是合法的。最后这页PPT是咱们这门课用的教科书配套的一页PPT，这是在解释求解puzzle的过程。大家看看有什么问题吗？

27:21
这页PPT的内容有什么问题吗？

27:42
为什么我把它单独拿出来？就是怕你们看这个PPT的时候有一些误解。

28:00
对，就这个地方的写法是容易引起误解的，是他是不是其实只能。但是他为什么把这个写成TS？就它容易给人一种误解，就是求哈希的时候是把这些交易的信息也放到里面一起求的哈希，这个是不对的。实际上求哈希的时候只是用到了block header的内容，而这些交易的具体信息在blog header里面是没有的。Blow header里只有一个mock tree的根哈希值，那个其实就够了，就已经能够保证整个区块里包含的交易是没有办法被篡改的。大家看这个PPT的时候就注意一下，不要产生误解。

28:58
我不是说让你去改这个PPT，要没有问题的话，我们就接着讲课，我把这个收起来了。下面我们对挖矿的过程做一些概率分析。挖矿就是不断的尝试各种nance来求解这个puzzle。每次尝试nance可以看作是一个bu trial。

30:10
A abloy trial is a random experiment with Better outcome. 大家能想到的最典型的blue trial的例子是什么？就是掷硬币对吧？每次扔一下硬币两种可能性，正面朝上或者是反面朝上，这两种可能性的概率不一定一样。比如说正面朝上的概率是P反面朝上的概率是一减P就这个硬币不一定是均匀的。对于我们这个挖矿的例子来说，这两个概率是非常的不一样。每次尝试一个nas成功的概率是微乎其微的，大概率是不行的。如果我们做很多的blud trial，每个实验都是随机的，那么这些布罗迪trial就构成了一个bloody process。

32:01
A sequence of independent bloody trial. 本奴隶process的一个性质是无记忆性。

32:19
所谓的memories property。这个意思是说，你做大量的实验，前面的实验结果对后面的实验是没有影响的。比如掷硬币，你掷很多次硬币都是反面朝上，那是不是说你下次再掷硬币的时候，正面朝上的概率就会大一些呢？不是的，仍然是原来的概率，正面朝上的概率始终都是P跟过去的实验结果是没有关系的。

32:58
那么对于挖矿来说？每次尝试成功的可能性很小，那么需要尝试大量的nas才有可能找到符合要求的。这种情况下，这个博罗利process可以用波松process来近似。

33:32
实验的次数很多，每次实验成功的概率很小。这时候可以用passon process来。我们关心的是什么？我们关心的是出块时间系统里产生下一个区块的时间。这个在概率上可以推导出来，这个出块时间是服从指数分布。

34:18
我们可以把它画一下。

34:31
这个纵轴是概率密度。

34:46
杭州市出块时间。Time to next block. 

35:01
大家注意，这是整个系统的出块时间，并不是每个具体矿工的出块时间。整个系统平均的出块时间是十分钟。

35:28
这个平均时间是比特币协议设计出来的，通过定期的调整挖矿难度，使得平均的出块时间维持在十分钟左右。具体到每一个矿工，它能够挖到下一个区块的时间取决于这个矿工的算力占系统总算力的百分比。比如说你的算力占到总算力的1%，那么平均下来，系统里每产生100个区块，其中有一个区块是你挖矿挖到的，那么你平均就要等1000分钟才能产生一个区块。这个指数分布。也是无记忆的，也是这个memory list。大家看这个probability density的这个曲线，这个概率密度曲线有什么特点呢？

36:39
你从任何一个地方把它截断，剩下这部分曲线的形状跟原来是一样的，仍然是服从指数分布，这就是它memories的性质。比如说现在已经过去了十分钟了，还没有人找到合法的权块，那么接下来还要再等多久呢？仍然是这个概率密度分布，平均还是要等十分钟。这个可能有点不太符合大家的直觉，因为感觉上说平均出块时间是十分钟。你现在已经挖了十分钟都还没有挖到，那么感觉上应该快了，应该很快就能挖到下一个区块了。不是这样的。就这个概率分析告诉大家将来还要挖多少时间，跟过去已经挖了多少时间是没有关系的。

37:43
仍然是服从这个指数分布，平均还是要十分钟，所以这个性质有的时候也管它叫。Progress, free. 就过去的progress是没有用的，是不算数的。大家有没有觉得这个性质很无情，过去做的工作都白做了。我们设想一下，如果有某个puzzle它不满足这个性质，不是progress freed，那么会出现什么情况？

38:36
比如说过去做的工作越多，那么接下来尝试nance的时候成功的概率就越大。就相当于掷硬币的时候，每次结果不是随机的。你过去制了好多次硬币都是反面朝上，那么你下次再掷硬币的时候，正面朝上概率就会增加。如果有某一个加密货币设计出这样一个puddle会有什么结果？

39:13
算力强的矿工会有不成比例的优势，因为算力强的矿工过去做的工作肯定是多的。什么叫不成比例的优势？比如系统中有两个矿工，一个的算力是另一个的十倍。那么理想状况下，算力强的矿工能够挖到矿，找到这个爬走lotion的概率也应该是另一个的十倍，这才算是公平。因为这个算力强的矿工能够尝试的nars的数目是另一个的十倍，这恰恰就是我们说的这个progress free，或者叫memories性质所保证的。

40:02
如果不是这样的话，那么算力强的矿工获得记账权的概率就会超过十倍。因为他过去尝试了那么多不成功的nars之后，下次nars成功的概率就会增大，这就叫做不成比例的优势。所以大家不要觉得这个progress free的性质很无情，其实它恰恰是挖矿公平性的保证。大家看看有什么问题吗？

41:49
下面我们分析一下比特币的总量。我们前面说过出块奖励就是那个block reward，是系统中产生新的比特币的唯一途径。而这个出块奖励是每隔四年要减半的。这样产生出来的比特币数量就构成了一个几何序列。

42:31
一开始的时候，21万个区块能够生成的比特币是50个。接下来的21万个区块。能够生成的比特币就变成了25个。再往下的21万个区块。变成了12.5个。

43:04
以此类推。

43:14
我们把这21万乘以50抽出来，这个里面是什么？一加上2分之1，加上4分之1。

43:35
这一部分。大家应该都很熟悉吧，这个是最经典的geometric theory。

43:54
这个等于2。所以整个等式化简成是21万乘以100 2100万。

44:13
这就是系统中所有比特币的总量，既包括过去已经挖出来的比特币，也包括未来将要产生的比特币，一共就这么多。

44:33
有一些不太了解比特币的人有一个错误的观点，以为这个挖矿是在解决某个数学难题。比如说寻找符合某种条件的质数，而比特币越来越难被挖到，是因为越到后面符合这种条件的质数就越来越少了。其实不是这样的，比特币求解的这个puzzle除了比拼算力之外，没有其他的实际意义。比特币越来越难被挖到是因为这个出块奖励被人为的减少了，他这样不断的减半，比特币的稀缺性是人为造成的。

45:32
这里大家注意一点，虽然我们说挖矿求解的这个puzzle本身是没有什么实际意义的。但是挖矿的过程对于维护比特币系统的安全性是至关重要的。所以有一种说法。

46:29
bitcoin. Is secured by money. 

46:55
对于一个去中心化的没有membership控制的系统来说，挖矿提供了一种凭借算力投票的有效手段。只要大部分算力是掌握在诚实的节点手里，系统的安全性就能够得到保证。所以挖矿这个过程虽然从表面上看没有什么实际意义，好像做的是无用功，还挺浪费电的。但是这个机制的设立，对于维护整个系统的安全性是非常有效的。

47:40
好，我们说出块奖励，每隔四年要减半，就会变得越来越小。那么是不是说大家挖矿的动力也会变得越来越小呢？从过去几年的情况来看，恰恰是相反的，挖矿的竞争是越来越激烈了。因为比特币的价格是飙升的，就虽然你得到的这个出块奖励的数目是减少了，但是价值反而更高了。当然了，从今年开始，比特币的价格又跌下来了，从原来最高的2万美元到现在大概是六千多美元。那么出块奖励越来越少，最后趋于零的时候，是不是大家就没有动力挖矿了也不是的。还有第二种激励机制，就是我们刚才讲过的交易费。大家对于这部分还有问题吗？

49:02
我们对比特币的安全性做一些分析，假设大部分算力是掌握在诚实的矿工手里，我们能得到什么样的安全保证？能不能保证写入区块链的交易都是合法的？能吗？大家注意，挖矿给出的只是个概率上的保证，只能说有比较大的概率。

49:37
下一个区块是由一个诚实的矿工发布的，但是不能保证记账权不会落到有恶意的节点手里。比如好的矿工占90%的算力，坏的矿工占10%的算力。那么平均下来10%的情况下，这个记账权会落到一个有恶意的节点手里。这时候会出现什么情况？

50:12
我们考虑第一个问题，他能不能投币，能不能把别人账上的钱转给他自己？不能因为他没有办法伪造别人的签名。就假设我们有一个节点。M是有恶意的，malicious他要把A账上的钱转走，所以他发布一个A转给M的这个交易。但这个交易要有A的签名才有效。M虽然获得记账权，但是他不知道A的寺庙，所以伪造不了A的签名。那他如果就把这个交易硬写到区块链里？

51:09
比如说这是当前的区块链。

51:23
现在M这个节点有记账权了，他发布一个区块就把这个交易硬往里写，会有什么结果？诚实的节点不会接受这个区块，因为它包含一个非法的交易，对吧？所以城市的节点会继续沿着上一个区块挖。就变成了这个样子。就是我们定义像这种攻击，有恶意的攻击是否成功的标准是要看他能不能让诚实的节点接受这个交易。如果仅仅是有恶意的节点之间互相认账，诚实的节点都不认账。那是没有用的。这个例子当中，城市的节点都会沿着上面这条点。

52:28
因为比特币要求是扩展最长合法链，这个不是合法链，它多长都没有用，它包含一个不合法的交易。所以这个区块实际上等于是作废了。这对于这个攻击者来说，付出的代价是很大的，因为他得不到出块奖励了，等于是没有偷到钱，而且还白白损失了8万美元，是这个攻击是成功不了。第二个问题，他能不能把已经花出的币再花一遍？就所谓的double spending，他能做到这一点吗？

53:31
比如说。M这个节点。发布一个转账交易给A已经写到区块链里了。现在他获得去记账权，他又发布另一个交易，把这个钱再转还给他自己。比如说M把钱再转给他自己。这个区块如果是时间连在后面，这肯定是不行的。因为这很明显的是double spending，凡是诚实的节点都不会接受这个区块，所以连在这儿是不行的。

54:22
他要想发布这个交易的话，他只能插在这个地方。

54:32
就是我们前面说的分叉工具的例子，forking attack. 大家注意，这个区块插在哪个位置是要在刚开始挖矿的时候就要决定了。因为设置的blog header里要填上前一个区块的哈希，所以M这个节点想插到这个位置的，一开始就要把这个区块设置成前一个区块，而不是说等获得记账权以后再说。那么这种情况下会有什么？错，两个等长的合法链，这都是合法的，取决于其他节点沿着哪一个链往下扩展，最后有一个会胜出，另一个就作废了。

55:32
那么这种攻击的目的是什么？如果上面这个转账交易M转给A的钱产生了某种不可逆的外部效果。下面再把这个交易给回滚了，那么M就可以从中不当获利。比如说网上购物。M购买一些商品，这个网站接受比特币支付。他发起一个交易说把账转给这个网站。这个网站监听到这个交易写入到区块链里了，以为支付成功了，所以就把商品给了MM拿到这个商品之后，又发起一个交易，把钱转给他自己，把下面这个扩展成最长合法链。

56:38
这样上面这个区块就作废了。所以他这样攻击的目的是既得到商品又把花出去的钱收回来了，就达到double spending attack的目的。那么怎么防范这种攻击呢？

57:13
如果这个转账交易不是在最后一个区块，而是后面又跟了几个区块。

57:31
这种攻击的难度就会大大增加。你要想回滚这个交易的话，还是得在这个地方插入，对吧？

57:50
还是要插在这儿，然后要想办法让这个成为最长合法链，这个难度是很大的。因为诚实的节点不会沿着这个区块往下扩展，为什么？因为它不是最长合把链上面这个链比它长，所以这个相当于是这两条链在赛跑。

58:19
如果大部分算力是掌握在城市节点手里，那么这样攻击成功的可能性很小。有恶意的节点只获得一次击掌权是不够的，还需要接下来不断的获得记账权才行。所以一种简单的防范这种攻击的方法就是多等几个区块，或者叫做多等几个确认。

59:00
就在这个地方，这个交易刚刚写到这个区块里的时候，我们管它叫one confirmation。

59:21
到了这里，后面又跟着一个区块就叫to confirmation，以此类推，就这个叫做three confirmation。

59:41
就是for confirmation，比特币协议当中缺省的是要等六个confirmation。

01:00:07
到这个时候才认为前面这个交易是不可篡改的。这个需要等多长时间呢？平均出块时间是十分钟，这个要等1个小时，所以这个等待时间还是很长的。大家应该都听过一种说法，说区块链是不可篡改的账本，叫做。

01:00:50
In revocable measure. 那是不是说凡是写入区块链的内容就永远都改不了呢？经过我们刚才的分析，大家应该明白，这种不可篡改性只是一种概率上的保证。刚刚写入区块链的内容，相对来说还是比较容易被改掉了。经过一段等待时间之后，或者说后面跟着好几个确认之后，被篡改的概率就大幅度的下降，指数级别的下降。

01:01:40
其实还有一种叫zero confirmation，零个确认。这个意思是说这个转账交易发布出去了，但是还没有被写到区块链里。这个例子当中，这个时间点。就对应着zero confirmation。

01:02:17
就这个交易已经发布出去了，但是下一个区块还没有被挖出来。就那个电商购物的例子当中，相当于你支付的时候，你发布一个转账交易，告诉电商我已经把钱转给你了。这个电商它运行一个全节点，或者是委托某个全节点监听区块链上的交易。他收到这个转账交易之后，要验证一下这个交易的合法性，有合法的签名，以前没有被花过，但是不用等到这个交易被写到区块链里。这个听起来风险很大是吧？这交易刚发布出去都没有往区块链里写了。

01:03:14
其实zero confirmation在实际当中用的还是比较普遍的，为什么呢？有两个原因，一个比特币协议缺省的设置是节点接收最先听到的那个交易，就两个交易有冲突，你最先收到哪一个就接收哪个。所以这个zero confirmation这个位置M转给A了，节点收到了，你再发布一个转给他自己的，有比较大的概率，诚实的节点是不会接受的。

01:03:58
第二点。很多购物网站，从你支付成功到他把货品发给你，是有一定的时间间隔的。它天然有一定的处理时间。比如说你要买个笔记本电脑。你在网上支付成功了，但是这个电商可能要第二天才会把这个电脑发货。所以如果发现你这个转账交易最后没有被写到最长合法链上，那么电商就可以选择取消发货就行了。这个相当于是比特币系统以外，还是有一些手段的。

01:04:49
好，回到我们前面那个问题，假设某个有恶意的节点获得记账权，他还能干什么坏事？能不能故意不把某些合法的交易写到区块链里？他发布的区块就故意不包含某些交易，这是可以的对吧？比特币协议并没有规定获得记账权的节点，一定要把那些交易发布到区块里。但是出现这种情况问题也不大，因为这些合法的交易反正可以被写到下一个区块里，就总有诚实的节点愿意发布这些交易。

01:05:40
其实区块链在正常工作情况下，也会出现合法的交易没有被包含进去的情况，可能就是这段时间交易的数目太多了。比特币协议中规定每个区块的大小是有限制的，最多不能超过一兆字节。所以如果交易的数目太多了，那么有些交易可能就只能等到下一个区块再发布。大家有问题吗？

01:06:19
那个攻击的话就是当他M转给A的时候，我刚开始转给A了，他后面六个确认还没有，就是我又转给我自己，有这个过程。但是我提前可不可以，我提前准备很，我就提前算好，比如说现在是第6000个区块，我把6001到010的我提前算。我就准备我把我自己自己转的就这一一笔交易，我就是然后我就给我自己软柿子，我提前把这个款全部算好，然后到时候暂时先不发布。对，然后等到时候M到A这一个区块出现，我立马开始分叉。因为我提前准备好了，所以我的分叉肯定比这6。大家听明白了吗？

01:07:03
我重复一下，就这个同学说为什么我说成功很难呢？因为这个交易发布出去之后，后面跟了这么多个确认，到6个确认，这时候你在这里分叉，让这条链去赶上这条链是太慢了。所以有一种攻击方法，是我这个先不发布，我偷偷的挖，挖出来的还不止挖一个，挖，它上面有六个区块，我挖的比它多，我挖出七个区块来先藏着，等到6个确认过了，对方把这个东西给我了，一下子都发不出去，一长串，把上面那个链给盖掉，是这意思吧？这种工艺方法有一个名字。叫selfish money。

01:08:07
这个本来我打算后面课上讲的，现在既然有人问到，我们提前讲了消费money。就是说正常情况下我们应该说是挖到一个区块马上就发布出去，原因是什么？你不发布的话，别人可能就发布了。别人发布之后你这个区块链作废了，等于得不到出块奖励了。就跟我们写论文一样，对吧？你写论文你有一个好的idea，你肯定是希望抢先发布出去。你不会说写好论文在办公室里藏着，你藏藏藏，最后别人先发表，你的论文不就作废了吗？

01:08:44
所以正常的情况是挖到区块马上发布，但这个selfish mining呢？不是的，selfish mining是挖到区块先藏了，先不急着发布。那么为什么要这么做呢？刚才那个同学举的例子就是forking attack分叉攻击的时候，我底下藏着一条链，然后突然一下都甩出来。就跟打扑克的时候，我有四个二炸弹把他们都给炸了，这是分叉工具的一种手段。

01:09:15
但这样做的话，有一个前提，就在大家想一想，普通的矿工这么做成功的可能性仍然是不大的。就如果我我前面那个例子，好的节点占90%的算力，有恶意的节点占10%的算力，那你这种藏着消费是manning的方法成功的概率并不大。你刚才想说什么？因为如果他在挖那个，比如说他他知道自己发布了一个M交易，然后他自己也想发一个M到M的。于是乎他在刚一发的时候，那个M到A的那块还没有挖出来，他就开始自己偷偷挖下面那一条链。但是他那个算力按你刚刚说的，如果只有10%的话，他还是竞争不过上面那一个。

01:10:05
对，就是这个前提。因为你这个藏着没有发布，所以这个块儿别的节点是不知道的，其他所有的节点能看到的是上面这条链，他都是沿着上面往下挖，只有你自己还有你的同伙会挖下面这条脸，所以这样的估计是有可能的。但是前提是有恶意的节点得占据很大一部分算力，比如说51%的算力，一半以上，这种成功的可能性才会比较大。不是我的意思。

01:10:38
假如说你现在挖到了1000个块，我直接把那个块号改成2000，我开始算超前，就是我1000个块，我开始算2000块，我意思我准备把这个挂到第2000号上，因此我现在算未来的两天地震，这是不可能的这是不可能的。你的意思是说我当前只挖出了1000个矿，你不你你不去挖1001个，你直接挖地2000个块，我后面要注意的几个提前准备好，那你怎么提前准备好？每一个块是要有前面一个区块的哈希，你前面区块没有挖出来，你没法提前准备好。所以说你前面后面全都算好了，结果这个块哈希对不上。对，你不可能提前，就是你不知道你不可能跳着去吧，这是不行的。我既然讲到这个地方，要不然咱们就多讲一点。

01:11:31
Selfish money还有什么目的？就是刚才那个同学举的是个分叉攻击的目的是为了底下能够挖出一个长串，然后一下子把它发布出去，把上面都盖掉。假设我们不是为了回滚以前的交易，就是为了正常的挖矿赚取出块奖励。Selfish money有没有什么好处？

01:12:42
有好处吗？写论文不投出去，先藏着。有好处吗？

01:12:53
其实也有一些好处，是什么呢？比如说某一个节点。就当前是这个样子。挖到一个区块，如果他马上发布的话，大家就都知道了。好，你这个区块链是这样的，然后我就沿着你这个往下挖就行了。大家一起原来是竞争这个区块的，下一个区块没有竞争成功，被你抢到了。那下面咱们就沿着这个往下竞争，重新开始竞争对吧？

01:13:35
如果他不发布？他不发布，别人以为这是最后一个区块，对吧？所以大家还是沿着这个再往下挖，是想挖这个区块。如果它的算力比较强，它已经挖到了再下一个区块，就这个还没有发布。别人还在抢着沿着这条链挖，他往下挖，他已经挖出了第二个区块。然后听到有人挖到上面这个区块，把这两个马上都发布出去，这样会出现什么情况？上面这个就白挖了，他得到两个除法奖励。

01:14:24
好处在什么地方？他减少了竞争。他如果一开始把这个发布出去的话，大家一起抢着挖下一个。现在他先不发布，其他人都在浪费算力挖这个。然后这前提是他的算力还是要足够强。然后别人挖出一个的时候，他已经挖出了两个，然后抛出去，这样这个就白玩了，我觉得他可以继续玩。你说继续挖，就别人发布一个的时候，他两个也不发布，他继续挖，再挖出三个来，然后等别人挖出两个的时候，他就发布出去了。这样风险很大，风险在哪里？

01:15:12
就是如果你们很长，然后你发不出结果，你可能最后算不过别人。别人运气稍微好一点，结果比你超前的，这样等于你什么都没有。对，就会出现什么情况？就是你挖出一个你不发布，但是你是以为在挖别人挖出这个的时候，你能挖到下一个。如果你没有发布，还没挖到下一个，别人已经挖出这个了，这时候是什么？这时候变成等长的链，对吧？这时候你要赶快把这个发布出去，跟别人抢一抢，有可能你还能抢得赢，这就是selfish money的一个风险。大家听明白了吗？

01:16:01
回报也不是很高。他能够在一定程度上对自己有好处，就是让别人做些无用的功，他少一些竞争。

01:16:15
好，我们今天基本上把比特币系统的具体实现就讲完了。这节课的内容也是比较多，大家回去好好消化吸收一下。接下来比特币系统中还有一些各个方方面面，我们下面会分成几个小专题再给大家介绍一下。
