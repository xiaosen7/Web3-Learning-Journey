北京大学肖臻老师《区块链技术与应用》公开课\_原文
2024 年 10 月 29 日 11:12
发言人 00:06
今天我们讲比特币交易中的脚本语言。这个交易有一个输入和两个输出。左边是输入，表示这个输入来自哪个交易的输出。右边是两个输出，其中一个已经花出去了，另一个还没花出去。这个交易已经有 23 个确认，回滚的可能性很小。

发言人 00:48
这是交易的输入和输出脚本。输入脚本有两个操作，把两个长字符串压入栈。比特币的脚本语言很简单，只有一个堆栈，没有全局变量、局部变量或动态内存。输出脚本有两行，每个输出有自己的脚本。

发言人 01:37
我们来看交易的具体内容。首先是元数据，包括交易 ID、哈希值、版本和大小。

发言人 02:03
锁定时间设定交易的生效时间，这里是零，表示立即生效。大多数情况下锁定时间都是 0。如果是非零值，交易要等一段时间才能生效，比如等十个区块。

发言人 02:38
vin 和 vout 是输入输出部分，后面会详细讲解。区块哈希是交易所在区块的哈希值，通常以一长串零开头，这是挖矿难度的结果。

发言人 03:03
确认数是交易的确认信息数量，这个交易有 23 个确认。时间是交易产生的时间，区块时间是区块产生的时间，表示从某个早期时间点到现在的秒数。

发言人 03:31
这是交易的输入结构，是个数组，一个交易可以有多个输入。这个例子中只有一个输入，每个输入都要说明币的来源。第一个交易 ID 是之前交易的哈希值，vout 表示是这个交易里的第几个输出。这个例子中，币来自哈希值开头为 C0CB 的交易中的第零个输出。

发言人 04:15
输入脚本叫 script sig，最简单的形式是给出一个签名，证明你有权利花这个钱。后面的 PPT 中，script sig 直接写成 input script。

发言人 04:37
如果一个交易有多个输入，每个输入都要说明币的来源并给出签名。比特币中的一个交易可能需要多个签名。这是交易的输出，也是一个数组结构。

发言人 04:55
这个例子中有两个输出，value 是输出的金额，单位是比特币，这里是 0.22684 个比特币。如果表示成 satoshi，就是 22684000 satoshi。

发言人 05:34
N 是序号，表示这是交易里的第几个输出。script pub key 是输出脚本，后面写成 output script。输出脚本最简单的形式是给出一个公钥。ASM 显示的是输出脚本的内容，包含一系列操作，后面会详细解释。

发言人 06:08
Request 表示输出需要多少个签名才能兑现，这两个例子中只需要一个签名。type 是输出的类型，这两个类型都是 public key hash。address 是输出的地址。下面看输入和输出脚本的执行。

发言人 06:42
上面画的是一个小型区块链。前面区块里有 A 给 B 的转账交易，B 收到币后在后面区块里转给 C。这个例子中，B 给 C 的交易中，B 的来源是 A 转给 B 的交易。B 转给 C 的交易的输入里，transaction ID 和 vout 指向 A 转给 B 的交易的输出。

发言人 07:26
验证交易的合法性，需要把 B 转给 C 的输入脚本和 A 转给 B 的输出脚本拼接在一起执行。前面交易的输出脚本放在后面，后面交易的输入脚本放在前面。早期比特币实践中，这两个脚本拼接在一起从头到尾执行。后来出于安全考虑，改为分别执行。首先执行输入脚本，如果没有出错，再执行输出脚本。如果顺利执行，栈顶结果为非零值，验证通过，交易合法。否则交易非法。如果一个交易有多个输入，每个输入脚本都要和对应的输出脚本匹配验证，全都通过交易才合法。

发言人 08:41
输入输出脚本的几种形式。最简单的是 pay to public key，输出脚本给出收款人的公钥，check sig 检查签名，输入脚本给出签名。签名是用私钥对输入脚本所在的整个交易签名。这种形式最简单，因为公钥直接在输出脚本里给出。实际执行情况是把输入脚本和输出脚本拼接后的结果，第一行来自输入脚本，后两行来自输出脚本。实际代码中出于安全考虑，这两段脚本分别执行。PPT 中为了方便，拼接在一起显示，从上往下一条语句执行。第一条语句把输入脚本提供的签名压入栈，第二条把输出提供的公钥压入栈，第三条 check sig 弹出栈顶两个元素，用公钥检查签名是否正确。如果正确，返回 true，验证通过，否则交易非法。

发言人 10:25
这是 pay to public key 的实例。输入脚本把签名压入栈，输出脚本有两行，第一行把公钥压入栈，第二行 check sig。这是第一种形式。

发言人 10:51
第二种形式是 pay to public key hash。区别在于输出脚本没有直接给出公钥，而是公钥的哈希。公钥在输入脚本里给出，输入脚本既要给出签名，也要给出公钥。输出脚本有一些操作，如 dup 和 hash 160，验证签名的正确性。这种形式最常用。

发言人 11:35
脚本执行结果是输入脚本和输出脚本拼接后的语句，前两条来自输入脚本，后面的来自输出脚本，从上往下执行。第一条语句把签名压入栈，第二条把公钥压入栈，第三条 dup 复制栈顶元素，栈顶多了一个公钥。hash 160 弹出栈顶元素取哈希，再压入栈，栈顶变成公钥的哈希值。

发言人 12:22
下一条语句把输出脚本提供的公钥哈希值压入栈，栈顶有两个哈希值。上面的是输出脚本提供的收款人公钥哈希，下面的是输入脚本提供的公钥哈希。equal verify 弹出栈顶两个元素，比较它们是否相等，防止冒名顶替。如果相等，栈顶消失。

发言人 13:34
最后一条 check sig 弹出栈顶两个元素，用公钥检查签名是否正确。如果签名正确，脚本顺利运行结束，栈顶留下 true。如果执行过程中任何环节出错，交易非法。

发言人 14:11
Pay to public key hash 是最常用的脚本形式。PPT 第一页的实例用的就是这种形式。input script 和 output script 输入脚本把签名和公钥压入栈，输出脚本复制栈顶元素 dup，取哈希值 hash 160，把公钥哈希压入栈，equal verify 比较栈顶两个哈希值，check sig 检查签名。

发言人 14:57
最复杂的脚本形式是 pay to script hash。输出脚本给出的不是公钥哈希，而是收款人提供的脚本哈希。这个脚本叫赎回脚本，将来花钱时，输入脚本要给出赎回脚本的具体内容和签名。

发言人 15:39
验证分两步。第一步验证输入脚本给出的赎回脚本是否与输出脚本给出的哈希值匹配。如果不匹配，验证失败。如果匹配，第二步执行赎回脚本的内容，验证签名的正确性。两步都通过，交易合法。

发言人 16:33
我们看一个具体例子，用 pay to script hash 实现 pay to public key 的功能。输入脚本给出签名和序列化的赎回脚本，赎回脚本内容是给出公钥并用 check sig 检查签名。输出脚本验证输入脚本给出的赎回脚本是否正确。

发言人 17:10
pay to script hash 的执行过程是把输入脚本和输出脚本拼接在一起。前两行来自输入脚本，后面三行来自输出脚本。

发言人 17:26
首先把输入脚本的签名压入栈，然后把赎回脚本压入栈，取哈希得到赎回脚本的哈希值。接下来把输出脚本给出的哈希值压入栈，栈里有两个哈希值。equal 比较两个哈希值是否相等，如果不等，验证失败。如果相等，哈希值从栈顶消失。

发言人 18:16
第一阶段验证结束，接下来进行第二阶段验证。反序列化输入脚本提供的赎回脚本，执行赎回脚本，先把公钥压入栈，用 check sig 验证输入脚本给出的签名的正确性。验证通过，pay to script hash 才算执行完成。

发言人 19:05
同学们可能会问，为什么不直接用 pay to public key？为什么要嵌入赎回脚本？确实对简单例子来说，这么做有点复杂。Pay to script hash 最初版本的比特币没有，后来通过软分叉加入。常见应用场景是多重签名支持。

发言人 19:52
比特币系统中一个输出可能要求多个签名才能取出钱。比如某公司账户要求五个合伙人中任意三个人的签名才能取钱。这样为私钥泄露提供安全保护。如果某个合伙人私钥泄露，问题不大，还需要另外两个人的签名才能取钱。同时为私钥丢失提供冗余。五个合伙人中即使有两人忘记私钥，剩下三人仍可取钱。这个功能通过 check multi sig 实现。输出脚本给出 N 个公钥，指定阈值 M。输入脚本提供 N 个公钥对应的 M 个签名通过验证。比如 N 等于 5，M 等于 3，五个合伙人中任意三人签名都可以。

发言人 21:30
输入脚本第一行有个红色叉子，比特币中 check multi sig 实现有个 bug，执行时会多弹出一个元素，这是代码实现的 bug。这个 bug 现在无法改，因为是去中心化系统。要改需要硬分叉。实际解决方案是在输入脚本里多压一个没用的元素。第一行红色叉子代表多余元素。为了迁就 check multi sig 的 bug，多压一个元素。注意 M 个签名的相对顺序要与 N 个公钥中的相对顺序一致。

发言人 22:46
这是 check multi sig 的执行过程。例子中假设三个签名中给出两个，签名的相对顺序与公钥中的顺序一致。第一个公钥排在第二个公钥前面，相应签名也是第一个签名排在第二个签名前面。

发言人 23:14
第一行的 false 是多余元素。首先把多余元素压入栈，然后把两个签名依次压入栈，输入脚本执行完。接下来输出脚本把 M 的值压入栈，把三个公钥压入栈，把 N 的值压入栈，最后执行 check multi sig 看堆栈里是否包含三个签名中的两个。如果是，验证通过。

发言人 24:05
大家有什么问题吗？

发言人 24:12
注意这个过程没有用到 pay to script hash，只用比特币脚本中原生的 check multi sig 实现。这么实现有什么问题吗？

发言人 24:33
早期多重签名就是这样实现的。在实际应用中有些不方便。比如网上购物，某电商用多重签名，要求五个合伙人中任意三人签名才能取钱。用户在网上购物时生成的转账交易里要给出五个合伙人的公钥，还要给出 N 和 M 的值。用户怎么知道这些信息？需要购物网站公布。网站可以公布多重签名规则和公钥，用户生成转账交易时填入这些信息。不同电商的多重签名规则不同，有的要求五个签名中任意三个，有的要求五个签名中四个，有的要求六个签名中三个。这给用户生成转账交易带来不便。

发言人 26:26
这些复杂性暴露给用户，怎么办？用 pay to script hash。它把复杂度从输出脚本转移到输入脚本。输出脚本变得简单，只有三行。复杂度转移到赎回脚本里。输出脚本只给出赎回脚本的哈希值。赎回脚本里给出 N 个公钥和 N、M 的值。

发言人 27:15
赎回脚本在输入脚本里提供，由收款人提供。像网上购物的例子，收款人是电商，他在网站上公布赎回脚本的哈希值，用户生成转账交易时把哈希值包含在输出脚本里。电商用什么多重签名规则对用户不可见，用户不需要知道。对用户来说，采用这种支付方式与 pay to public key hash 没多大区别，只是把公钥哈希换成赎回脚本哈希。输出脚本写法有些区别，但不是本质性的。

发言人 28:24
输入脚本是电商花掉这笔输出时提供的，包含赎回脚本的序列化版本和所需的 M 个签名。如果电商改变多重签名规则，比如从五个里选三个变成三个里选两个，只需改变输入脚本和赎回脚本内容，然后公布新的哈希值。对用户来说，只是付款时包含的哈希值变了，其他变化不需要知道。

发言人 29:13
具体执行过程是把输入脚本和输出脚本拼接在一起。第一行的 false 是为了应付 check multi sig 的 bug，先压入栈。然后依次把两个签名压入栈，再把序列化的赎回脚本作为数据压入栈。

发言人 29:49
输入脚本执行完，输出脚本取哈希，把输出脚本提供的哈希值压入栈顶，判断两个哈希值是否相等，第一阶段验证完成。

发言人 30:16
第二阶段验证，把赎回脚本展开后执行，先把 M 压入栈，把三个公钥压入栈，把 N 压入栈，最后检查多重签名的正确性，三个里有两个正确。第二阶段验证过程与直接使用 check multi sig 类似。

发言人 30:51
这是网上使用 pay to script hash 做多重签名的实例。输入脚本最后一个是序列化的赎回脚本，反序列化后得到三个里取两个的多重签名脚本。输出脚本内容与前面讲的一样。现在多重签名一般采用 pay to script hash 形式。

发言人 31:24
最后讲一种特殊的脚本格式。输出脚本开头是 return 操作，后面可以跟任意内容。return 操作无条件返回错误，包含这个操作的脚本永远无法通过验证。执行到 return 语句就会出错，执行终止，后面内容不会执行。同学们可能觉得奇怪，为什么要设计这样的输出脚本？这样的输出永远花不出去，不论输入脚本写什么内容，执行到 return 语句就报错，钱永远花不出去，确实如此。

发言人 32:25
这个脚本是销毁比特币的方法。为什么要销毁比特币？比特币这么值钱，销毁岂不是可惜？一般有两种应用场景，一种是小币种要求销毁一定数量比特币才能得到这个币种。有时称这种小币种为 altcoin。

发言人 33:08
就是 alternative coin。

发言人 33:21
比特币之外的其他小加密货币都可以称为 altcoin。比如有的小币种要求销毁一个比特币，得到 1000 个小币。用这种方法证明付出一定代价才能得到小币种。

发言人 33:44
另一种应用场景是往区块链里写入一些内容。区块链是不可篡改的账本，有人利用这个特性往里面添加需要永久保存的内容。比如第一节课讲的数字承诺（digital commitment）。

发言人 34:28
你要证明在某个时间知道某些事情。比如说涉及到知识产权保护的，把某项知识产权的内容取哈希之后，把哈希值放在这个 return 语句的后面。这后面的内容反正是永远不会执行的，你往里写什么都没关系。而且你放在这里的是一个哈希值，你有什么知识产权，取个哈希之后，把哈希值放在这，这个不会占太大的地方，而且也没有泄露出来你知识产权的具体内容。将来如果出现纠纷，像知识产权的一些专利诉讼，那么你再把这个具体内容公布出去，把这个哈希值的当初的输入公布出去，证明你在某个时间点已经知道某个知识了。

发言人 35:29
同学们有没有觉得这个应用场景听起来比较耳熟？我们以前课上讲其他某个地方的时候，也讲到类似的应用场景。就是那个 coinbase 域对吧？我们讲。

发言人 36:02
Coinbase 交易里面有一个 coinbase 域，你在这个域里写什么内容，同样是没人管的。所以为什么不用这种方法？这个还不用销毁比特币了，就可以直接往里写。

发言人 36:24
这种方法只有获得记账权的那个节点才能用。如果你是一个全节点，你挖矿挖到了，然后你发布一个区块，可以往这个 coinbase 交易里的 coinbase 域写入一些内容，这是可以的。而我们说的这种方法，是所有的节点都可以用的。甚至你不一定是个节点，可能就是一个普通的比特币用户，任何人都可以用这种方法去写入一些内容。大家听明白了吗？发布交易不需要有记账权，发布区块才需要有记账权。任何用户都可以用这种方法销毁很少一点比特币。比如说 0.0001 个比特币，换取往这个区块链里面写入一些内容的机会。

发言人 37:26
我们接下来会看一些例子，有些交易其实根本就没有销毁比特币，只不过支付了交易费。我们下面看两个实例。这是个 coinbase 交易，这个交易有两个输出。第一个输出的脚本是正常的 pay to public key hash，输出的金额就是得到的区块奖励加上交易费。第二个输出的金额是 0，输出脚本就是刚才说的那种格式，开头是 return，后面跟了一些乱七八糟的内容。第二个输出的目的就是为了往区块链里写一些东西。

发言人 38:18
这是个普通的转账交易，输出脚本也是以 return 开头的。这个交易的输入是 0.05 个比特币，输出金额是 0，说明输入金额全部用来支付交易费了。这个交易其实并没有销毁任何比特币，只不过把输入里的比特币作为交易费转给这个挖到矿的矿工了。

发言人 38:49
这种形式的脚本的一个好处是，矿工看到这种脚本的时候，知道它里面的输出永远不可能兑现。所以就没有必要把它保存在 UTXO 里面，这样对全节点是比较友好的。大家有什么问题吗？就有一点说明一下，我们这个 PPT 当中涉及到的比特币脚本的操作，为了简单起见，都没有加上 op 前缀。就比如说我们前面写的 check sig 实际上应该是 op_checksig，那么 check multi sig 也是 op_checkmultisig，还有这个 dup 应该也叫做 op_dup。我们这个 PPT 简单起见就没有把它写上去。

发言人 39:55
最后总结一下，比特币系统当中用的这个脚本语言是非常简单的，甚至连专门的名字都没有。它就叫比特币脚本语言（Bitcoin Scripting Language）。我们后面可以看到像以太坊当中用的智能合约的语言，这就比这个要复杂得多。比如说比特币的脚本语言不支持循环，所以有很多功能这个语言是实现不了的。这样的设计是有其用意的。不支持循环就不会有死循环，就不用担心停机问题，大家听说过吧？Halting problem。像以太坊当中，它的智能合约的语言是图灵完备的，表达能力很强。所以就需要靠汽油费的机制来防止这个程序陷入死循环。

发言人 41:01
另外一方面，我们注意这个语言虽然在某些方面功能是很有限的，但是在另外一些方面它的功能却很强大，就是跟密码学相关的功能是很强大的。比如说这个 check multi sig 检查多重签名，用一条语句就能够完成，这个比很多通用的编程语言要方便得多。所以比特币的脚本语言虽然看上去很简单，但其实针对比特币的应用场景做了很好的优化。还有问题吗？我们这节课就上到这儿。
